---
import { Image } from "astro:assets";
import HeroImg from "../../assets/sosc_hero.svg";
---

<div id="sticky-container" class="relative h-[250vh] w-full bg-white">
  <section
    id="hero-section"
    class="sticky top-0 flex h-screen w-full flex-col items-center justify-center overflow-hidden"
  >
    <div
      class="pointer-events-none absolute inset-0 flex items-center justify-center select-none"
      style={{ transform: "scale(clamp(0.35, calc(100vw / 1500px), 1))" }}
    >
      <Image
        src={HeroImg}
        alt="HeroImage"
        width={733}
        height={202}
        class="absolute top-1/4 max-w-none shrink-0"
      />
    </div>

    <div
      id="hero-text"
      class="pointer-events-none absolute inset-0 z-50 flex items-center justify-center opacity-0 select-none"
      style={{ transform: "scale(clamp(0.25, calc(100vw / 1500px), 1))" }}
    >
      <h1 class="text-foreground absolute z-10 text-[82px] whitespace-nowrap">
        MAY THE <span class="font-bold text-white">SOURCE</span> BE WITH YOU
      </h1>
    </div>

    <div
      id="grid-flash-container"
      class="pointer-events-none absolute inset-0 z-10"
    >
    </div>
  </section>
</div>

<script>
  function init() {
    const container = document.getElementById("grid-flash-container");
    const stickyContainer = document.getElementById("sticky-container");
    const heroText = document.getElementById("hero-text");

    if (!container || !stickyContainer) return;

    const THEME_COLOR = "#3ce56e";
    let BLOCK_SIZE = 50;

    interface Block {
      el: HTMLDivElement;
      r: number;
      seed: number;
      roughness: number;
    }

    let blocks: Block[] = [];

    function initGrid() {
      if (!container) return;
      container.innerHTML = "";
      blocks = [];

      const w = window.innerWidth;
      const h = window.innerHeight;

      // Responsive block sizing
      BLOCK_SIZE = w < 768 ? 40 : 50;

      const cols = Math.ceil(w / BLOCK_SIZE);
      const rows = Math.ceil(h / BLOCK_SIZE);

      // Calculate offsets to center the grid of blocks
      const offsetX = (w % BLOCK_SIZE) / 2;
      const offsetY = (h % BLOCK_SIZE) / 2;

      for (let r = -1; r <= rows; r++) {
        for (let c = -1; c <= cols; c++) {
          const pixel = document.createElement("div");
          pixel.className = "flash-block";

          // We add +1px to width/height to ensure no sub-pixel gaps (white lines)
          pixel.style.width = `${BLOCK_SIZE + 1}px`;
          pixel.style.height = `${BLOCK_SIZE + 1}px`;
          pixel.style.left = `${offsetX + c * BLOCK_SIZE}px`;
          pixel.style.top = `${offsetY + r * BLOCK_SIZE}px`;
          pixel.style.backgroundColor = THEME_COLOR;

          container.appendChild(pixel);

          blocks.push({
            el: pixel,
            r,
            seed: Math.random(),
            roughness: (Math.random() - 0.5) * 3, // Increased roughness for a more organic feel
          });
        }
      }
      updateBlocks();
    }

    function updateBlocks() {
      if (!stickyContainer || !blocks.length) return;

      const rect = stickyContainer.getBoundingClientRect();
      const h = window.innerHeight;
      const rows = Math.floor(h / BLOCK_SIZE);

      const totalScrollable = rect.height - h;
      const progress = Math.max(0, Math.min(1, -rect.top / totalScrollable));

      // Finish the "climb" slightly before the scroll ends (at 85% progress)
      const animationProgress = Math.min(1, progress * 1.18);

      // Starting state: bottom 2 rows are filled
      const currentBaseRow = rows - 1.5 - animationProgress * (rows + 10);

      // Animate text opacity: start at 0.85, full at 1.0
      if (heroText) {
        const textOpacity = Math.max(0, (animationProgress - 0.60) / 0.15);
        heroText.style.opacity = textOpacity.toString();
      }

      blocks.forEach((block) => {
        // Apply roughness to create the jagged rising edge
        const effectiveRow =
          block.r + block.roughness * (1 - animationProgress);
        const distFromFloor = effectiveRow - currentBaseRow;

        if (distFromFloor >= 0) {
          // SOLID ZONE: Below the floor
          block.el.style.opacity = "1";
        } else if (distFromFloor > -4) {
          // FRAGMENTED ZONE: Just above the floor (4 rows high)
          const distIndex = Math.abs(distFromFloor);
          const density = 0.9 - (distIndex - 1) * 0.25;

          if (block.seed < density) {
            const op = 0.8 - (distIndex - 1) * 0.2;
            block.el.style.opacity = op.toString();
          } else {
            block.el.style.opacity = "0";
          }
        } else {
          // EMPTY ZONE: Far above the floor
          block.el.style.opacity = "0";
        }
      });
    }

    window.addEventListener("resize", initGrid);
    window.addEventListener("scroll", updateBlocks);
    initGrid();

    return () => {
      window.removeEventListener("resize", initGrid);
      window.removeEventListener("scroll", updateBlocks);
    };
  }

  let cleanup: () => void;
  // Initialize on both direct load and view transitions
  document.addEventListener("astro:page-load", () => {
    if (cleanup) cleanup();
    cleanup = init() as () => void;
  });
</script>

<style is:global>
  .flash-block {
    position: absolute;
    pointer-events: none;
    /* Use will-change for smooth scrolling performance */
    will-change: opacity;
    /* This makes the rise look snappy but not flickering */
    transition: opacity 0.12s linear;
  }

  /* Optional: adds a very subtle highlight between blocks to maintain a techy feel */
  .flash-block::after {
    content: "";
    position: absolute;
    inset: 0;
    border-right: 1px solid rgba(255, 255, 255, 0.05);
    border-bottom: 1px solid rgba(255, 255, 255, 0.05);
  }
</style>
